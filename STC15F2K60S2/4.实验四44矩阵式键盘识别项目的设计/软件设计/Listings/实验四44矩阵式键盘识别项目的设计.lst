C51 COMPILER V9.57.0.0   ______44________________________                                  11/22/2021 17:10:24 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE ______44________________________
OBJECT MODULE PLACED IN .\Objects\实验四44矩阵式键盘识别项目的设计.obj
COMPILER INVOKED BY: E:\keil_v5\C51\BIN\C51.EXE 实验四44矩阵式键盘识别项目的设计.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECT
                    -EXTEND PRINT(.\Listings\实验四44矩阵式键盘识别项目的设计.lst) OBJECT(.\Objects\实验四44矩阵式键盘识别项目的设计.obj)

line level    source

   1          /////////////////////////////////////////////////////////////////////////////////
   2          //设计项目:4x4控制数码管设计实验                                               //
   3          //设 计 人:畅福善                                                              //
   4          //设计时间:2014.5.5                                                            //
   5          //设计说明:设计一个开关计数器， 实现一个4x4键盘，控制数码管显示                //
   6          //         利用数码管依次显示，1 2 3 4 5 6 7 8 9 A B C D E F                   //
   7          //         硬件连接条件:1、单片机P0.0~P0.7依次连接第1~8个LED指示灯             //
   8          //                      2、4个模拟开关依次连接到P3.4,P3.5,P3.6,P3.7            //
   9          //                      3、数码管数据连接IC7 锁存控制P2.6                      //
  10          //                      4、数码管数据连接IC6 锁存控制P2.7                      //
  11          /////////////////////////////////////////////////////////////////////////////////
  12          
  13          //#include <AT89X51.H> 
  14          //#include "STC89C52RC.H"
  15          #include "stc15f2k60s2.h"
  16          ////////函数说明////////
  17          void delay02s(void);            //延时2秒子程序//
  18          void delay10ms(void);           //延时10ms的子程序//
  19          void delay500us(void);          //延时500us的子程序//
  20          void delay50us(void);           //延时50us的子程序//
  21          
  22          void key(void);             //按键函数
  23          void key44(void);           //4*4按键函数
  24          
  25          void display(void);         //二极管8421显示函数
  26          void display_seg(void);     //数码管显示函数 
  27          void display_seg1(void);     //34个、数码管显示函数 
  28          
  29          void baojing(void);         //报警函数 
  30          void alarm_buzzer(void);        //按键音
  31          
  32          void display_ceshi(void);       //2个数码管自检程序
  33          void display_ceshi_8(void); //8个数码管自检程序
  34          void display_seg_8(void);
  35          void ceshiyin(void);       //蜂鸣器自检
  36          
  37          void addition_calculators(void);//加法计算器
  38          
  39          ////////变量说明////////
  40          //led定义
  41          sbit L1=P1^0;//////定义第1个指示灯的名称为L1  还可以直接采用P0_0;因为AT89X51.H内部已做定义,下依次类推
  42          sbit L2=P1^1;//////定义第2个指示灯的名称为L2 
  43          sbit L3=P1^2;//////定义第3个指示灯的名称为L3  
  44          sbit L4=P1^3;//////定义第4个指示灯的名称为L4 
  45          sbit L5=P1^4;//////定义第5个指示灯的名称为L5  
  46          sbit L6=P1^5;//////定义第6个指示灯的名称为L6 
  47          sbit L7=P1^6;//////定义第7个指示灯的名称为L7  
  48          sbit L8=P1^7;//////定义第8个指示灯的名称为L8 
  49          //独立按键定义
  50          sbit key_1=P3^4;//////定义第1个独立按键为KEY_1
  51          sbit key_2=P3^5;//////定义第2个独立按键为KEY_2
  52          sbit key_3=P3^6;//////定义第3个独立按键为KEY_3
  53          sbit key_4=P3^7;//////定义第4个独立按键为KEY_4
  54          //4*4按键定义
C51 COMPILER V9.57.0.0   ______44________________________                                  11/22/2021 17:10:24 PAGE 2   

  55          sbit line_1=P2^0;//////定义第1行
  56          sbit line_2=P2^1;//////定义第2行
  57          sbit line_3=P2^2;//////定义第3行
  58          sbit line_4=P2^3;//////定义第4行
  59          
  60          sbit row_1=P3^4;//////定义第1列
  61          sbit row_2=P3^5;//////定义第2列
  62          sbit row_3=P4^2;//////定义第3列
  63          sbit row_4=P4^4;//////定义第4列
  64          ///////////////////////////////////////
  65          sbit fmq=P3^2;//////定义fmq为蜂鸣器控制端
  66          /////////////////////////////////////////
  67          unsigned  char count;/////////按键计数器
  68          unsigned  char w;
  69          unsigned  char code table[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x
             -71,0x40,0x00,0x41};////数码管显示码表
  70          //////////////////////////////0     1    2    3    4    5    6    7    8    9   A    B     C    D    E    F     
             -  -   
  71          unsigned  char SEG_1,SEG_2,SEG_3,SEG_4,SEG_5,SEG_6,SEG_7,SEG_8;//////8个数码管显示单元定义
  72          ///////////////0     1      2      3     4     5    6     7                                              
  73          unsigned  char shiwei;//10位数据
  74          unsigned  char gewei;//个位数据                                 
  75          
  76          unsigned  char temp_i;//分析按键临时变量 
  77          unsigned  char seg_key;//数码管临时按键显示变量 
  78          bit flag_baojing;///////定义报警标志
  79          
  80          void main(void)                         //主程序//
  81          {   
  82   1      /////////初始化区////////////////
  83   1      display_ceshi();
  84   1      display_ceshi_8();
  85   1      ceshiyin();
  86   1      
  87   1      
  88   1      //////////IO口输入初始化////////////////////
  89   1      line_1=1;line_2=1;line_3=1;line_4=1;row_1=1;row_2=1;row_3=1;row_4=1;
  90   1      //////////数码管初始化////////////////////
  91   1      ///数码管自检
  92   1      //////////蜂鸣器初始化////////////////////
  93   1      
  94   1              while(1)                            //进入循环//以下为无限循环程序区
  95   1              { 
  96   2                       key44();                       //调用4*4按键函数/2/
  97   2                       //display();         //调用显示函数//
  98   2                       display_seg();     //调用位数码管显示函数
  99   2                       //addition_calculators();
 100   2              } 
 101   1      }
 102          ///////////////////////////////////////////////////
 103          //函数名称:void key(void)
 104          //函数功能:按键函数
 105          //入口参数:
 106          //出口参数:
 107          //函数说明:
 108          ///////////////////////////////////////////////////
 109          void key(void)      //按键函数
 110          {
 111   1              if(key_1==0)/////////如果按键按下
 112   1              {
 113   2                delay10ms();///////延时10ms
 114   2                if(key_1==0)///////按键的确按下
C51 COMPILER V9.57.0.0   ______44________________________                                  11/22/2021 17:10:24 PAGE 3   

 115   2                  {
 116   3                      count++;///////按键计数器计数           
 117   3                      if(count>=16){count=0;}//////控制计数器最大值;16即为16进制;20即为20进制;但最大计数255，因为count定义的是
             -unsigend char
 118   3                      if(count>=10)
 119   3                              {
 120   4                              flag_baojing=1;//////计数器超过10给出报警标志;
 121   4                              }
 122   3                      else
 123   3                              {
 124   4                              flag_baojing=0;//////计数器未超过10取消报警标志;
 125   4                              }
 126   3      //              P0=~count;///////将计数值送P0口利用LED指示灯以BCD码（8421码）显示
 127   3                      while(key_1==0){;}///////按键等待抬起
 128   3                      }
 129   2              }
 130   1              if(key_2==0)/////////如果按键按下
 131   1              {
 132   2                delay10ms();///////延时10ms
 133   2                if(key_2==0)///////按键的确按下
 134   2                  {
 135   3                      flag_baojing=0;//////手动取消报警标志;
 136   3                      while(key_2==0){;}///////按键等待抬起
 137   3                      }
 138   2              }
 139   1      }
 140          
 141          ///////////////////////////////////////////////////
 142          //函数名称:void key44(void)
 143          //函数功能:按键函数
 144          //入口参数:
 145          //出口参数:
 146          //函数说明:一种4*4键盘
 147          //4*4按键定义
 148          //sbit line_1=P2^0;//////定义第1行
 149          //sbit line_2=P2^1;//////定义第2行
 150          //sbit line_3=P2^2;//////定义第3行
 151          //sbit line_4=P2^3;//////定义第4行
 152          //
 153          //sbit row_1=P3^4;//////定义第1列
 154          //sbit row_2=P3^5;//////定义第2列
 155          //sbit row_3=P4^2;//////定义第3列
 156          //sbit row_4=P4^4;//////定义第4列
 157          //
 158          //sbit fmq=P3^2;//////定义fmq为蜂鸣器控制端
 159          ///////////////////////////////////////////////////
 160          void key44(void)
 161          {
 162   1      line_1=1;line_2=1;line_3=1;line_4=1;row_1=1;row_2=1;row_3=1;row_4=1;
 163   1      /////////////////////扫描第一行//////////////////////////////////////// 
 164   1              line_1=0;                                                           //将第一行P20置0，扫描第一行4列
 165   1      //扫描第一列
 166   1              if(row_1==0)                                                    //扫描第一列P34是否被按下
 167   1              {
 168   2                      delay10ms();                                            //延时10ms，消抖
 169   2                      if(row_1==0)                                            //重新检测
 170   2                      {                       
 171   3                              //fmq=0;
 172   3                              alarm_buzzer();                 //按键音
 173   3                              seg_key=7;                                              //识别第一行第一列，并给出数码管显示内容
 174   3                      }
 175   2                      while(row_1==0){display_seg();}                                 //在按键按下时，让程序停在这里，等待弹起
C51 COMPILER V9.57.0.0   ______44________________________                                  11/22/2021 17:10:24 PAGE 4   

 176   2              }//fmq=1;                                                                       //按键声音结束
 177   1      //扫描第二列    
 178   1              if(row_2==0)                                                    //扫描第二列P35是否被按下
 179   1              {
 180   2                      delay10ms();                                            //延时10ms，消抖
 181   2                      if(row_2==0)                                            //重新检测
 182   2                      {                       
 183   3                              //fmq=0;
 184   3                              alarm_buzzer();                 //按键音
 185   3                              seg_key=8;                                              //识别第二列，并给出数码管显示内容
 186   3                      }
 187   2                      while(row_2==0){display_seg();}                                 //在按键按下时，让程序停在这里，等待弹起
 188   2              }//fmq=1;                                                                       //按键声音结束
 189   1      //扫描第三列    
 190   1              if(row_3==0)                                                    //扫描第三列P42是否被按下
 191   1              {
 192   2                      delay10ms();                                            //延时10ms，消抖
 193   2                      if(row_3==0)                                            //重新检测
 194   2                      {                       
 195   3                              //fmq=0;
 196   3                              alarm_buzzer();                 //按键音
 197   3                              seg_key=9;                                              //识别第三列，并给出数码管显示内容
 198   3                      }
 199   2                      while(row_3==0){display_seg();}                                 //在按键按下时，让程序停在这里，等待弹起
 200   2              }//fmq=1;
 201   1      //扫描第四列    
 202   1              if(row_4==0)                                                    //扫描第四列P44是否被按下
 203   1              {
 204   2                      delay10ms();                                            //延时10ms，消抖
 205   2                      if(row_4==0)                                            //重新检测
 206   2                      {                       
 207   3                              //fmq=0;
 208   3                              alarm_buzzer();                 //按键音
 209   3                              seg_key=10;                                             //识别第四列，并给出数码管显示内容
 210   3                      }
 211   2                      while(row_4==0){display_seg();}                                 //在按键按下时，让程序停在这里，等待弹起
 212   2              }//fmq=1;       
 213   1      
 214   1              line_1=1;                                                       //第一行扫描检测完毕，将P20置1
 215   1              
 216   1      /////////////////////扫描第二行//////////////////////////////////////// 
 217   1              line_2=0;                                                           //将第二行P21置0，扫描第二行4列
 218   1      //扫描第一列
 219   1              if(row_1==0)                                                    //扫描第一列P34是否被按下
 220   1              {
 221   2                      delay10ms();                                            //延时10ms，消抖
 222   2                      if(row_1==0)                                            //重新检测
 223   2                      {                       
 224   3                              //fmq=0;
 225   3                              alarm_buzzer();                 //按键音
 226   3                              seg_key=4;                                              //识别第一列，并给出数码管显示内容
 227   3                      }
 228   2                      while(row_1==0){display_seg();}                                 //在按键按下时，让程序停在这里，等待弹起
 229   2              }//fmq=1;                                                                       //按键声音结束
 230   1      //扫描第二列    
 231   1              if(row_2==0)                                                    //扫描第二列P35是否被按下
 232   1              {
 233   2                      delay10ms();                                            //延时10ms，消抖
 234   2                      if(row_2==0)                                            //重新检测
 235   2                      {                       
 236   3                              //fmq=0;
 237   3                              alarm_buzzer();                 //按键音
C51 COMPILER V9.57.0.0   ______44________________________                                  11/22/2021 17:10:24 PAGE 5   

 238   3                              seg_key=5;                                              //识别第二列，并给出数码管显示内容
 239   3                      }
 240   2                      while(row_2==0){display_seg();}                                 //在按键按下时，让程序停在这里，等待弹起
 241   2              }//fmq=1;                                                                       //按键声音结束
 242   1      //扫描第三列    
 243   1              if(row_3==0)                                                    //扫描第三列P42是否被按下
 244   1              {
 245   2                      delay10ms();                                            //延时10ms，消抖
 246   2                      if(row_3==0)                                            //重新检测
 247   2                      {                       
 248   3                              //fmq=0;
 249   3                              alarm_buzzer();                 //按键音
 250   3                              seg_key=6;                                              //识别第三列，并给出数码管显示内容
 251   3                      }
 252   2                      while(row_3==0){display_seg();}                                 //在按键按下时，让程序停在这里，等待弹起
 253   2              }//fmq=1;
 254   1      //扫描第四列    
 255   1              if(row_4==0)                                                    //扫描第四列P44是否被按下
 256   1              {
 257   2                      delay10ms();                                            //延时10ms，消抖
 258   2                      if(row_4==0)                                            //重新检测
 259   2                      {                       
 260   3                              //fmq=0;
 261   3                              alarm_buzzer();                 //按键音
 262   3                              seg_key=11;                                             //识别第四列，并给出数码管显示内容
 263   3                      }
 264   2                      while(row_4==0){display_seg();}                                 //在按键按下时，让程序停在这里，等待弹起
 265   2              }//fmq=1;       
 266   1      
 267   1              line_2=1;                                                       //第二行扫描检测完毕，将P21置1  
 268   1      /////////////////////扫描第三行//////////////////////////////////////// 
 269   1              line_3=0;                                                           //将第三行P22置0，扫描第三行4列
 270   1      //扫描第一列
 271   1              if(row_1==0)                                                    //扫描第一列P34是否被按下
 272   1              {
 273   2                      delay10ms();                                            //延时10ms，消抖
 274   2                      if(row_1==0)                                            //重新检测
 275   2                      {                       
 276   3                              //fmq=0;
 277   3                              alarm_buzzer();                 //按键音
 278   3                              seg_key=1;                                              //识别第一列，并给出数码管显示内容
 279   3                      }
 280   2                      while(row_1==0){display_seg();}                                 //在按键按下时，让程序停在这里，等待弹起
 281   2              }//fmq=1;                                                                       //按键声音结束
 282   1      //扫描第二列    
 283   1              if(row_2==0)                                                    //扫描第二列P35是否被按下
 284   1              {
 285   2                      delay10ms();                                            //延时10ms，消抖
 286   2                      if(row_2==0)                                            //重新检测
 287   2                      {                       
 288   3                              //fmq=0;
 289   3                              alarm_buzzer();                 //按键音
 290   3                              seg_key=2;                                              //识别第二列，并给出数码管显示内容
 291   3                      }
 292   2                      while(row_2==0){display_seg();}                                 //在按键按下时，让程序停在这里，等待弹起
 293   2              }//fmq=1;                                                                       //按键声音结束
 294   1      //扫描第三列    
 295   1              if(row_3==0)                                                    //扫描第三列P42是否被按下
 296   1              {
 297   2                      delay10ms();                                            //延时10ms，消抖
 298   2                      if(row_3==0)                                            //重新检测
 299   2                      {                       
C51 COMPILER V9.57.0.0   ______44________________________                                  11/22/2021 17:10:24 PAGE 6   

 300   3                              //fmq=0;
 301   3                              alarm_buzzer();                 //按键音
 302   3                              seg_key=3;                                              //识别第三列，并给出数码管显示内容
 303   3                      }
 304   2                      while(row_3==0){display_seg();  }                               //在按键按下时，让程序停在这里，等待弹起
 305   2              }//fmq=1;
 306   1      //扫描第四列    
 307   1              if(row_4==0)                                                    //扫描第四列P44是否被按下
 308   1              {
 309   2                      delay10ms();                                            //延时10ms，消抖
 310   2                      if(row_4==0)                                            //重新检测
 311   2                      {                       
 312   3                              //fmq=0;
 313   3                              alarm_buzzer();                 //按键音
 314   3                              seg_key=12;                                             //识别第四列，并给出数码管显示内容
 315   3                      }
 316   2                      while(row_4==0){display_seg();}                                 //在按键按下时，让程序停在这里，等待弹起
 317   2              }//fmq=1;       
 318   1      
 319   1              line_3=1;                                                       //第三行扫描检测完毕，将P22置1
 320   1      /////////////////////扫描第四行//////////////////////////////////////// 
 321   1              line_4=0;                                                           //将第四行P23置0，扫描第三行4列
 322   1      //扫描第一列
 323   1              if(row_1==0)                                                    //扫描第一列P34是否被按下
 324   1              {
 325   2                      delay10ms();                                            //延时10ms，消抖
 326   2                      if(row_1==0)                                            //重新检测
 327   2                      {                       
 328   3                              //fmq=0;
 329   3                              alarm_buzzer();                 //按键音
 330   3                              seg_key=0;                                              //识别第一列，并给出数码管显示内容
 331   3                      }
 332   2                      while(row_1==0){display_seg();}                                 //在按键按下时，让程序停在这里，等待弹起
 333   2              }//fmq=1;                                                                       //按键声音结束
 334   1      //扫描第二列    
 335   1              if(row_2==0)                                                    //扫描第二列P35是否被按下
 336   1              {
 337   2                      delay10ms();                                            //延时10ms，消抖
 338   2                      if(row_2==0)                                            //重新检测
 339   2                      {                       
 340   3                              //fmq=0;
 341   3                              alarm_buzzer();                 //按键音
 342   3                              seg_key=15;                                             //识别第二列，并给出数码管显示内容
 343   3                      }
 344   2                      while(row_2==0){display_seg();}                                 //在按键按下时，让程序停在这里，等待弹起
 345   2              }//fmq=1;                                                                       //按键声音结束
 346   1      //扫描第三列    
 347   1              if(row_3==0)                                                    //扫描第三列P42是否被按下
 348   1              {
 349   2                      delay10ms();                                            //延时10ms，消抖
 350   2                      if(row_3==0)                                            //重新检测
 351   2                      {                       
 352   3                              //fmq=0;
 353   3                              alarm_buzzer();                 //按键音
 354   3                              seg_key=14;                                             //识别第三列，并给出数码管显示内容
 355   3                      }
 356   2                      while(row_3==0){display_seg();}                                 //在按键按下时，让程序停在这里，等待弹起
 357   2              }//fmq=1;
 358   1      //扫描第四列    
 359   1              if(row_4==0)                                                    //扫描第四列P44是否被按下
 360   1              {
 361   2                      delay10ms();                                            //延时10ms，消抖
C51 COMPILER V9.57.0.0   ______44________________________                                  11/22/2021 17:10:24 PAGE 7   

 362   2                      if(row_4==0)                                            //重新检测
 363   2                      {                       
 364   3                              //fmq=0;
 365   3                              alarm_buzzer();                 //按键音
 366   3                              seg_key=13;                                             //识别第四列，并给出数码管显示内容
 367   3                      }
 368   2                      while(row_4==0){display_seg();}                                 //在按键按下时，让程序停在这里，等待弹起
 369   2              }//fmq=1;       
 370   1      
 371   1              line_4=1;                                                       //第四行扫描检测完毕，将P22置1
 372   1                      ///////数码管显示内容准备///////
 373   1                      SEG_1=16;SEG_2=16;SEG_3=16;SEG_4=16;SEG_5=16;SEG_6=16;SEG_7=16;SEG_8=16;//8个数码管显示单元送无数据数//
 374   1                      SEG_2=seg_key;//利用1位数码管显示键盘数字或字符//,可调可调整到数码管的任意位置  
 375   1      }
 376          ///////////////////////////////////////////////////
 377          //函数名称:void baojing(void)
 378          //函数功能:报警函数
 379          //入口参数:
 380          //出口参数:
 381          //函数说明:
 382          ///////////////////////////////////////////////////
 383          void baojing(void)
 384          {
 385   1      unsigned  int baojing_i;
 386   1                        for(baojing_i=100;baojing_i>0;baojing_i--)
 387   1                         {
 388   2                          P14=~P14;               //P1_0取反//
 389   2                              delay500us();            //延时500us//
 390   2                         }
 391   1      }
 392          
 393          
 394          
 395          
 396          ///////////////////////////////////////////////////
 397          //函数名称:void display(void)
 398          //函数功能:显示函数
 399          //入口参数:
 400          //出口参数:
 401          //函数说明:
 402          ///////////////////////////////////////////////////
 403          void display(void)      //LED显示函数
 404          {
 405   1      //////////////持续显示程序/////////////////////////////
 406   1              P1=~count;///////将计数值送P0口利用LED指示灯以BCD码（8421码）显示
 407   1              delay02s();
 408   1      //////////////闪烁显示函数/////////////////////////////
 409   1      /*
 410   1              P0=~count;///////将计数值送P0口利用LED指示灯以BCD码（8421码）显示
 411   1              delay02s();///延时0.2s
 412   1              P0=0xff;///////P0口8条线全送高电平，目的熄灭所有LED指示灯
 413   1              delay02s();///延时0.2s
 414   1      */
 415   1      }
 416          ///////////////////////////////////////////////////
 417          //函数名称:void display_seg(void)
 418          //函数功能:数码管显示函数
 419          //入口参数:
 420          //出口参数:
 421          //函数说明:
 422          ///////////////////////////////////////////////////
 423          void display_seg(void)      //显示函数
C51 COMPILER V9.57.0.0   ______44________________________                                  11/22/2021 17:10:24 PAGE 8   

 424          {
 425   1              
 426   1      //SEG_8=seg_key%10;
 427   1      //SEG_7=seg_key/10;     
 428   1      /////////1位显示//////////////////////
 429   1      P0=table[SEG_1];//////数据从P0口送出到IC7---74HC573锁存器
 430   1      P26=0;P26=1;P26=0;///IC7数据锁存
 431   1      P0=~0x10;//////位码从P0口送出到IC6---74HC573锁存器
 432   1      P27=0;P27=1;P27=0;///IC6位码数据锁存
 433   1           delay500us();///延时500us
 434   1      /////////黑屏显示//////////////////////
 435   1      P0=table[17];//////数据从P0口送出到IC7---74HC573锁存器
 436   1      P26=0;P26=1;P26=0;///IC7数据锁存//////clk信号
 437   1      P0=~0x00;//////位码从P0口送出到IC6---74HC573锁存器
 438   1      P27=0;P27=1;P27=0;///IC6位码数据锁存
 439   1      /////////2位显示//////////////////////
 440   1      P0=table[SEG_2];//////数据从P0口送出到IC7---74HC573锁存器
 441   1      P26=0;P26=1;P26=0;///IC7数据锁存
 442   1      P0=~0x20;//////位码从P0口送出到IC6---74HC573锁存器
 443   1      P27=0;P27=1;P27=0;///IC6位码数据锁存
 444   1           delay500us();///延时500us
 445   1      /////////黑屏显示//////////////////////
 446   1      P0=table[17];//////数据从P0口送出到IC7---74HC573锁存器
 447   1      P26=0;P26=1;P26=0;///IC7数据锁存//////clk信号
 448   1      P0=~0x00;//////位码从P0口送出到IC6---74HC573锁存器
 449   1      P27=0;P27=1;P27=0;///IC6位码数据锁存
 450   1      /////////3位显示//////////////////////
 451   1      P0=table[SEG_3];//////数据从P0口送出到IC7---74HC573锁存器
 452   1      P26=0;P26=1;P26=0;///IC7数据锁存
 453   1      P0=~0x40;//////位码从P0口送出到IC6---74HC573锁存器
 454   1      P27=0;P27=1;P27=0;///IC6位码数据锁存
 455   1           delay500us();///延时500us
 456   1      /////////黑屏显示//////////////////////
 457   1      P0=table[17];//////数据从P0口送出到IC7---74HC573锁存器
 458   1      P26=0;P26=1;P26=0;///IC7数据锁存//////clk信号
 459   1      P0=~0x00;//////位码从P0口送出到IC6---74HC573锁存器
 460   1      P27=0;P27=1;P27=0;///IC6位码数据锁存
 461   1      /////////4位显示//////////////////////
 462   1      P0=table[SEG_4];//////数据从P0口送出到IC7---74HC573锁存器
 463   1      P26=0;P26=1;P26=0;///IC7数据锁存
 464   1      P0=~0x80;//////位码从P0口送出到IC6---74HC573锁存器
 465   1      P27=0;P27=1;P27=0;///IC6位码数据锁存
 466   1           delay500us();///延时500us
 467   1      /////////黑屏显示//////////////////////
 468   1      P0=table[17];//////数据从P0口送出到IC7---74HC573锁存器
 469   1      P26=0;P26=1;P26=0;///IC7数据锁存//////clk信号
 470   1      P0=~0x00;//////位码从P0口送出到IC6---74HC573锁存器
 471   1      P27=0;P27=1;P27=0;///IC6位码数据锁存
 472   1      /////////5位显示//////////////////////
 473   1      P0=table[SEG_5];//////数据从P0口送出到IC7---74HC573锁存器
 474   1      P26=0;P26=1;P26=0;///IC7数据锁存
 475   1      P0=~0x01;//////位码从P0口送出到IC6---74HC573锁存器
 476   1      P27=0;P27=1;P27=0;///IC6位码数据锁存
 477   1           delay500us();///延时500us
 478   1      /////////黑屏显示//////////////////////
 479   1      P0=table[17];//////数据从P0口送出到IC7---74HC573锁存器
 480   1      P26=0;P26=1;P26=0;///IC7数据锁存//////clk信号
 481   1      P0=~0x00;//////位码从P0口送出到IC6---74HC573锁存器
 482   1      P27=0;P27=1;P27=0;///IC6位码数据锁存
 483   1      /////////6位显示//////////////////////
 484   1      P0=table[SEG_6];//////数据从P0口送出到IC7---74HC573锁存器
 485   1      P26=0;P26=1;P26=0;///IC7数据锁存
C51 COMPILER V9.57.0.0   ______44________________________                                  11/22/2021 17:10:24 PAGE 9   

 486   1      P0=~0x02;//////位码从P0口送出到IC6---74HC573锁存器
 487   1      P27=0;P27=1;P27=0;///IC6位码数据锁存
 488   1           delay500us();///延时500us
 489   1      /////////黑屏显示//////////////////////
 490   1      P0=table[17];//////数据从P0口送出到IC7---74HC573锁存器
 491   1      P26=0;P26=1;P26=0;///IC7数据锁存//////clk信号
 492   1      P0=~0x00;//////位码从P0口送出到IC6---74HC573锁存器
 493   1      P27=0;P27=1;P27=0;///IC6位码数据锁存
 494   1      /////////7位显示//////////////////////
 495   1      P0=table[SEG_7];//////数据从P0口送出到IC7---74HC573锁存器
 496   1      P26=0;P26=1;P26=0;///IC7数据锁存
 497   1      P0=~0x04;//////位码从P0口送出到IC6---74HC573锁存器
 498   1      P27=0;P27=1;P27=0;///IC6位码数据锁存
 499   1           delay500us();///延时500us
 500   1      /////////黑屏显示//////////////////////
 501   1      P0=table[17];//////数据从P0口送出到IC7---74HC573锁存器
 502   1      P26=0;P26=1;P26=0;///IC7数据锁存//////clk信号
 503   1      P0=~0x00;//////位码从P0口送出到IC6---74HC573锁存器
 504   1      P27=0;P27=1;P27=0;///IC6位码数据锁存
 505   1      /////////8位显示//////////////////////
 506   1      P0=table[SEG_8];//////数据从P0口送出到IC7---74HC573锁存器
 507   1      P26=0;P26=1;P26=0;///IC7数据锁存
 508   1      P0=~0x08;//////位码从P0口送出到IC6---74HC573锁存器
 509   1      P27=0;P27=1;P27=0;///IC6位码数据锁存
 510   1           delay500us();///延时500us
 511   1      /////////黑屏显示//////////////////////
 512   1      P0=table[17];//////数据从P0口送出到IC7---74HC573锁存器
 513   1      P26=0;P26=1;P26=0;///IC7数据锁存//////clk信号
 514   1      P0=~0x00;//////位码从P0口送出到IC6---74HC573锁存器
 515   1      P27=0;P27=1;P27=0;///IC6位码数据锁存
 516   1      }
 517          ///////////////////////////////////////////////////
 518          //函数名称:void alarm_buzzer(void)
 519          //函数功能:报警子程序
 520          //入口参数:
 521          //出口参数:
 522          //函数说明:
 523          ///////////////////////////////////////////////////
 524          void alarm_buzzer(void)         //按键音
 525          {               
 526   1                      unsigned char k; /////局部变量定义
 527   1                      for(k=248;k>0;k--) ////内层循环
 528   1                      {
 529   2                      fmq=1;
 530   2                      delay50us();
 531   2                      fmq=0;
 532   2                      delay50us();
 533   2                      }
 534   1                      fmq=1;
 535   1      } 
 536          void ceshiyin(void)
 537          {
 538   1                              unsigned char k; /////局部变量定义
 539   1                      for(k=248;k>0;k--) ////内层循环
 540   1                      {
 541   2                      fmq=1;
 542   2                      delay10ms();
 543   2                      fmq=0;
 544   2                      delay10ms();
 545   2                      }
 546   1                      fmq=1;
 547   1      }
C51 COMPILER V9.57.0.0   ______44________________________                                  11/22/2021 17:10:24 PAGE 10  

 548          ///////////////////////////////////////////////////
 549          //函数名称:void delay50us(void)
 550          //函数功能:延时50us秒的子程序
 551          //入口参数:
 552          //出口参数:
 553          //函数说明:
 554          ///////////////////////////////////////////////////
 555          void delay50us(void)            //延时50us的子程序//
 556          {               
 557   1                      unsigned int k; /////局部变量定义
 558   1      
 559   1                              for(k=50;k>0;k--) ////内层循环
 560   1                                      {
 561   2                                      ;
 562   2                                      }
 563   1      
 564   1      }  
 565          
 566          ///////////////////////////////////////////////////
 567          //函数名称:void delay500us(void)
 568          //函数功能:延时500us秒的子程序
 569          //入口参数:
 570          //出口参数:
 571          //函数说明:
 572          ///////////////////////////////////////////////////
 573          void delay500us(void)           //延时10ms的子程序//
 574          {               
 575   1      //              unsigned char i,j,k; /////局部变量定义
 576   1      //              unsigned char j,k; /////局部变量定义
 577   1                      unsigned char k; /////局部变量定义
 578   1      //              for(i=20;i>0;i--)   //最外层循环
 579   1      //                      {
 580   1      //                      for(j=20;j>0;j--)   // 上层循环
 581   1      //                                      {
 582   1                                                      for(k=248;k>0;k--) ////内层循环
 583   1                                                              {
 584   2                                                              ;
 585   2                                                              }
 586   1      //                                      }
 587   1      //                      }
 588   1      }  
 589          ///////////////////////////////////////////////////
 590          //函数名称:void delay10ms(void)
 591          //函数功能:延时10ms秒的子程序
 592          //入口参数:
 593          //出口参数:
 594          //函数说明:
 595          ///////////////////////////////////////////////////
 596          void delay10ms(void)            //延时10ms的子程序//
 597          {               
 598   1      //              unsigned char i,j,k; /////局部变量定义
 599   1                      unsigned char j,k; /////局部变量定义
 600   1      //              for(i=20;i>0;i--)   //最外层循环
 601   1      //                      {
 602   1                              for(j=20;j>0;j--)   // 上层循环
 603   1                                              {
 604   2                                                      for(k=248;k>0;k--) ////内层循环
 605   2                                                              {
 606   3                                                              ;
 607   3                                                              }
 608   2                                              }
 609   1      //                      }
C51 COMPILER V9.57.0.0   ______44________________________                                  11/22/2021 17:10:24 PAGE 11  

 610   1      } 
 611           
 612          ///////////////////////////////////////////////////
 613          //函数名称:void delay02s(void)
 614          //函数功能:延时0.2秒的子程序
 615          //入口参数:
 616          //出口参数:
 617          //函数说明:
 618          ///////////////////////////////////////////////////
 619          void delay02s(void)             //延时子程序//
 620          {               
 621   1                      unsigned char i,j,k; /////局部变量定义
 622   1                      for(i=20;i>0;i--)   //最外层循环
 623   1                              {
 624   2                              for(j=20;j>0;j--)   // 上层循环
 625   2                                              {
 626   3                                                      for(k=248;k>0;k--) ////内层循环
 627   3                                                              {
 628   4                                                              ;
 629   4                                                              }
 630   3                                              }
 631   2                              }
 632   1      }
 633          ///////////////////////////////////////////////////
 634          //函数名称:void jiafa(void)
 635          //函数功能:报警函数
 636          //入口参数:jsq_1,jsq_2
 637          //出口参数:
 638          //函数说明:
 639          ///////////////////////////////////////////////////
 640          void jsq_jiafa(void)
 641          {
 642   1      /*
 643   1      //////////////进入加法////////////////
 644   1              if(seg_key==14)&&(jsq==5)
 645   1              {
 646   1              jiafa_flag1=1;
 647   1              }
 648   1      SEG_1=
 649   1      //////////////获取加法第一个数////////////////
 650   1              if(jiafa_flag==1)
 651   1              {
 652   1              jsq_1=seg_key;
 653   1              }
 654   1      //////////////获取加法键号////////////////
 655   1              if(jiafa_flag==1)&&(seg_key==15)
 656   1              {
 657   1              jiafa_flag2=1;  
 658   1              }
 659   1      //////////////获取加法第二个数////////////////
 660   1              if(jiafa_flag2==1)
 661   1              {
 662   1              jsq_2=seg_key;
 663   1              }
 664   1      //////////////获取等号键////////////////
 665   1              if(jiafa_flag==1)&&(jiafa_flag==2)(seg_key==11)
 666   1              {
 667   1              jiafa_flag3=1;  
 668   1              }
 669   1      //////////////实现加法运算////////////////
 670   1              if(jiafa_flag3==1)
 671   1              {
C51 COMPILER V9.57.0.0   ______44________________________                                  11/22/2021 17:10:24 PAGE 12  

 672   1              sum=jsq_1+jsq_2;
 673   1              }
 674   1      
 675   1      */
 676   1      } 
 677          void display_ceshi(void)     //数码管测试函数 
 678          {
 679   1              unsigned char i;
 680   1              unsigned int j;
 681   1              count=110;
 682   1                for(i=0;i<10;i++)
 683   1                 {
 684   2                 count=count-11;
 685   2                        for(j=0;j<800;j++)
 686   2                         {
 687   3                         display_seg1();
 688   3                         }
 689   2                      }
 690   1      }
 691          void display_seg1(void)      //4个数码管显示函数
 692          {
 693   1      //count=17;
 694   1      //////////////显示数据处理程序/////////////////////////////
 695   1      shiwei=count/10;//得到10位数据
 696   1      gewei=count%10;//得到个位数据
 697   1      
 698   1      
 699   1      /////////十位显示//////////////////////
 700   1      P0=table[shiwei];//////数据从P0口送出到IC7---74HC573锁存器
 701   1      P26=0;P26=1;P26=0;///IC7数据锁存//////clk信号
 702   1      P0=~0x40;//////位码从P0口送出到IC6---74HC573锁存器
 703   1      P27=0;P27=1;P27=0;///IC6位码数据锁存
 704   1              //delay10ms();///延时10ms
 705   1          delay500us();
 706   1      /////////黑屏显示//////////////////////
 707   1      P0=table[17];//////数据从P0口送出到IC7---74HC573锁存器
 708   1      P26=0;P26=1;P26=0;///IC7数据锁存//////clk信号
 709   1      P0=~0x00;//////位码从P0口送出到IC6---74HC573锁存器
 710   1      P27=0;P27=1;P27=0;///IC6位码数据锁存
 711   1              //delay10ms();///延时10ms
 712   1          //delay500us();
 713   1      /////////个位显示//////////////////////
 714   1      P0=table[gewei];//////数据从P0口送出到IC7---74HC573锁存器
 715   1      P26=0;P26=1;P26=0;///IC7数据锁存
 716   1      P0=~0x80;//////位码从P0口送出到IC6---74HC573锁存器
 717   1      P27=0;P27=1;P27=0;///IC6位码数据锁存
 718   1              //delay10ms();///延时10ms
 719   1          delay500us();
 720   1      /////////黑屏显示//////////////////////
 721   1      P0=table[17];//////数据从P0口送出到IC7---74HC573锁存器
 722   1      P26=0;P26=1;P26=0;///IC7数据锁存//////clk信号
 723   1      P0=~0x00;//////位码从P0口送出到IC6---74HC573锁存器
 724   1      P27=0;P27=1;P27=0;///IC6位码数据锁存
 725   1              //delay10ms();///延时10ms
 726   1          //delay500us();
 727   1      
 728   1      }
 729          void display_ceshi_8(void)     //8个数码管测试函数 
 730          {
 731   1              unsigned int i,k;
 732   1              unsigned int j=10;
 733   1      for(k=0;k<10;k++)
C51 COMPILER V9.57.0.0   ______44________________________                                  11/22/2021 17:10:24 PAGE 13  

 734   1      {
 735   2      j=j-1;
 736   2      
 737   2                for(i=0;i<400;i++)//i越小 自检时间越短
 738   2                 {
 739   3      
 740   3                      SEG_1=j;SEG_2=j;SEG_3=j;SEG_4=j;SEG_5=j;SEG_6=j;SEG_7=j;SEG_8=j;
 741   3      
 742   3                      display_seg();     //8个调用数码管显示函数
 743   3      
 744   3                      }
 745   2      }
 746   1      
 747   1      }
 748          void display_seg_8(void)      //8个数码管显示函数
 749          {
 750   1      //count=123;
 751   1      //SEG_1=4;
 752   1      //SEG_2=3;
 753   1      //SEG_3=8;
 754   1      //SEG_4=9;
 755   1      //SEG_5=7;
 756   1      //SEG_6=2;
 757   1      //SEG_7=5;
 758   1      //SEG_8=6;
 759   1      //////////////显示数据处理程序/////////////////////////////
 760   1      ///*
 761   1      //SEG_5=count/1000;//得到1000位数据
 762   1      //SEG_6=(count%1000)/100;//得到个位数据100
 763   1      //SEG_7=((count%1000)%100)/10;//得到10位数据
 764   1      //SEG_8=((count%1000)%100)%10;//得到个位数据
 765   1      
 766   1      //*/
 767   1      //////////////显示程序/////////////////////////////
 768   1      
 769   1      /////////1位显示//////////////////////
 770   1      P0=table[SEG_1];//////数据从P0口送出到IC7---74HC573锁存器
 771   1      P26=0;P26=1;P26=0;///IC7数据锁存
 772   1      P0=~0x01;//////位码从P0口送出到IC6---74HC573锁存器
 773   1      P27=0;P27=1;P27=0;///IC6位码数据锁存
 774   1           delay500us();///延时500us
 775   1      
 776   1      /////////黑屏显示//////////////////////
 777   1      P0=table[17];//////数据从P0口送出到IC7---74HC573锁存器
 778   1      P26=0;P26=1;P26=0;///IC7数据锁存//////clk信号
 779   1      P0=~0x00;//////位码从P0口送出到IC6---74HC573锁存器
 780   1      P27=0;P27=1;P27=0;///IC6位码数据锁存
 781   1              //delay10ms();///延时10ms
 782   1          //delay500us();
 783   1      
 784   1      /////////2位显示//////////////////////
 785   1      P0=table[SEG_2];//////数据从P0口送出到IC7---74HC573锁存器
 786   1      P26=0;P26=1;P26=0;///IC7数据锁存
 787   1      P0=~0x02;//////位码从P0口送出到IC6---74HC573锁存器
 788   1      P27=0;P27=1;P27=0;///IC6位码数据锁存
 789   1           delay500us();///延时500us
 790   1      /////////黑屏显示//////////////////////
 791   1      P0=table[17];//////数据从P0口送出到IC7---74HC573锁存器
 792   1      P26=0;P26=1;P26=0;///IC7数据锁存//////clk信号
 793   1      P0=~0x00;//////位码从P0口送出到IC6---74HC573锁存器
 794   1      P27=0;P27=1;P27=0;///IC6位码数据锁存
 795   1              //delay10ms();///延时10ms
C51 COMPILER V9.57.0.0   ______44________________________                                  11/22/2021 17:10:24 PAGE 14  

 796   1          //delay500us();
 797   1      
 798   1      /////////3位显示//////////////////////
 799   1      P0=table[SEG_3];//////数据从P0口送出到IC7---74HC573锁存器
 800   1      P26=0;P26=1;P26=0;///IC7数据锁存
 801   1      P0=~0x04;//////位码从P0口送出到IC6---74HC573锁存器
 802   1      P27=0;P27=1;P27=0;///IC6位码数据锁存
 803   1           delay500us();///延时500us
 804   1      /////////黑屏显示//////////////////////
 805   1      P0=table[17];//////数据从P0口送出到IC7---74HC573锁存器
 806   1      P26=0;P26=1;P26=0;///IC7数据锁存//////clk信号
 807   1      P0=~0x00;//////位码从P0口送出到IC6---74HC573锁存器
 808   1      P27=0;P27=1;P27=0;///IC6位码数据锁存
 809   1              //delay10ms();///延时10ms
 810   1          //delay500us();
 811   1      /////////4位显示//////////////////////
 812   1      P0=table[SEG_4];//////数据从P0口送出到IC7---74HC573锁存器
 813   1      P26=0;P26=1;P26=0;///IC7数据锁存
 814   1      P0=~0x08;//////位码从P0口送出到IC6---74HC573锁存器
 815   1      P27=0;P27=1;P27=0;///IC6位码数据锁存
 816   1           delay500us();///延时500us
 817   1      /////////黑屏显示//////////////////////
 818   1      P0=table[17];//////数据从P0口送出到IC7---74HC573锁存器
 819   1      P26=0;P26=1;P26=0;///IC7数据锁存//////clk信号
 820   1      P0=~0x00;//////位码从P0口送出到IC6---74HC573锁存器
 821   1      P27=0;P27=1;P27=0;///IC6位码数据锁存
 822   1              //delay10ms();///延时10ms
 823   1          //delay500us();
 824   1      /////////5位显示//////////////////////
 825   1      P0=table[SEG_5];//////数据从P0口送出到IC7---74HC573锁存器
 826   1      P26=0;P26=1;P26=0;///IC7数据锁存
 827   1      P0=~0x10;//////位码从P0口送出到IC6---74HC573锁存器
 828   1      P27=0;P27=1;P27=0;///IC6位码数据锁存
 829   1           delay500us();///延时500us
 830   1      /////////黑屏显示//////////////////////
 831   1      P0=table[17];//////数据从P0口送出到IC7---74HC573锁存器
 832   1      P26=0;P26=1;P26=0;///IC7数据锁存//////clk信号
 833   1      P0=~0x00;//////位码从P0口送出到IC6---74HC573锁存器
 834   1      P27=0;P27=1;P27=0;///IC6位码数据锁存
 835   1              //delay10ms();///延时10ms
 836   1          //delay500us();
 837   1      /////////6位显示//////////////////////
 838   1      P0=table[SEG_6];//////数据从P0口送出到IC7---74HC573锁存器
 839   1      P26=0;P26=1;P26=0;///IC7数据锁存
 840   1      P0=~0x20;//////位码从P0口送出到IC6---74HC573锁存器
 841   1      P27=0;P27=1;P27=0;///IC6位码数据锁存
 842   1           delay500us();///延时500us
 843   1      /////////黑屏显示//////////////////////
 844   1      P0=table[17];//////数据从P0口送出到IC7---74HC573锁存器
 845   1      P26=0;P26=1;P26=0;///IC7数据锁存//////clk信号
 846   1      P0=~0x00;//////位码从P0口送出到IC6---74HC573锁存器
 847   1      P27=0;P27=1;P27=0;///IC6位码数据锁存
 848   1              //delay10ms();///延时10ms
 849   1          //delay500us();
 850   1      /////////7位显示//////////////////////
 851   1      P0=table[SEG_7];//////数据从P0口送出到IC7---74HC573锁存器
 852   1      P26=0;P26=1;P26=0;///IC7数据锁存
 853   1      P0=~0x40;//////位码从P0口送出到IC6---74HC573锁存器
 854   1      P27=0;P27=1;P27=0;///IC6位码数据锁存
 855   1           delay500us();///延时500us
 856   1      /////////黑屏显示//////////////////////
 857   1      P0=table[17];//////数据从P0口送出到IC7---74HC573锁存器
C51 COMPILER V9.57.0.0   ______44________________________                                  11/22/2021 17:10:24 PAGE 15  

 858   1      P26=0;P26=1;P26=0;///IC7数据锁存//////clk信号
 859   1      P0=~0x00;//////位码从P0口送出到IC6---74HC573锁存器
 860   1      P27=0;P27=1;P27=0;///IC6位码数据锁存
 861   1              //delay10ms();///延时10ms
 862   1          //delay500us();
 863   1      /////////8位显示//////////////////////
 864   1      P0=table[SEG_8];//////数据从P0口送出到IC7---74HC573锁存器
 865   1      P26=0;P26=1;P26=0;///IC7数据锁存
 866   1      P0=~0x80;//////位码从P0口送出到IC6---74HC573锁存器
 867   1      P27=0;P27=1;P27=0;///IC6位码数据锁存
 868   1           delay500us();///延时500us
 869   1      /////////黑屏显示//////////////////////
 870   1      P0=table[17];//////数据从P0口送出到IC7---74HC573锁存器
 871   1      P26=0;P26=1;P26=0;///IC7数据锁存//////clk信号
 872   1      P0=~0x00;//////位码从P0口送出到IC6---74HC573锁存器
 873   1      P27=0;P27=1;P27=0;///IC6位码数据锁存
 874   1              //delay10ms();///延时10ms
 875   1          //delay500us();
 876   1      
 877   1      
 878   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1523    ----
   CONSTANT SIZE    =     19    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     14      13
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
