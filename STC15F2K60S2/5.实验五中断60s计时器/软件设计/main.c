/////////////////////////////////////////////////////////////////////////////////
//设计项目:定时器_中断_计数器实验                                              //
//设 计 人:王志俊															   //
//设计时间:2021.11.29                                                           //
//设计说明:设计一个开关计数器， 实现一个模拟开关连续计数，控制8个LED指示灯显示 //
//         利用两位数码管显示，增加数据报警功能，和按键取消报警                //
//         硬件连接条件:1、单片机P0.0~P0.7依次连接第1~8个LED指示灯             //
//                      2、4个模拟开关依次连接到P3.4,P3.5,P3.6,P3.7            //
//                      3、数码管数据连接IC7 锁存控制P2.6                      //
//                      4、数码管数据连接IC6 锁存控制P2.7                      //
/////////////////////////////////////////////////////////////////////////////////
#include <STC15F2K60S2.h> 

////////函数说明////////
void delay02s(void);		//延时2秒子程序//
void delay10ms(void);		//延时10ms的子程序//
void delay500us(void);		//延时500us的子程序//
void delay50us(void);		//延时50us的子程序//

void key(void);             //按键函数

void display(void);         //显示函数
void display_seg(void);     //数码管显示函数 

void baojing(void);         //报警函数 
void int_time0(void);       //t0定时器初始化函数  
void alarm_buzzer(void);    //动态报警子函数
void anjianyin(void);
void display_ceshi_8(void); //八位自检
////////变量说明////////
//led定义
sbit L1=P1^0;//////定义第1个指示灯的名称为L1  还可以直接采用P0_0;因为AT89X51.H内部已做定义,下依次类推
sbit L2=P1^1;//////定义第2个指示灯的名称为L2 
sbit L3=P1^2;//////定义第3个指示灯的名称为L3  
sbit L4=P1^3;//////定义第4个指示灯的名称为L4 
sbit L5=P1^4;//////定义第5个指示灯的名称为L5  
sbit L6=P1^5;//////定义第6个指示灯的名称为L6 
sbit L7=P1^6;//////定义第7个指示灯的名称为L7  
sbit L8=P1^7;//////定义第8个指示灯的名称为L8 
//按键定义
sbit key_1=P3^4;//////定义第1个按键为KEY_1
sbit key_2=P3^5;//////定义第1个按键为KEY_2
sbit key_3=P4^2;//////定义第1个按键为KEY_3
sbit key_4=P4^4;//////定义第1个按键为KEY_4
/////////////////////////////
unsigned  char count;/////////按键计数器

unsigned  char code table[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71,0x40};////数码管显示码表
//////////////////////////////0     1    2    3    4    5    6    7    8    9	A    B     C    D    E    F					 

////////数码管显示定义////////
unsigned  char shiwei;//10位数据
unsigned  char gewei;//个位数据                            	
unsigned  char SEG_1,SEG_2,SEG_3,SEG_4,SEG_5,SEG_6,SEG_7,SEG_8;//////8个数码管显示单元定义

////////与报警有关定义////////
bit flag_baojing;///////定义报警标志
unsigned char  jsq_baojing;///////定义报警时间长短计数器
/////////////////////////////
sbit fmq=P3^2;//////定义fmq为蜂鸣器控制端

////////与时间有关定义////////
///////50ms计数器和1S计数器
unsigned char jsq_50ms,jsq_1s,jsq_2s=99;///////50ms计数器和1S计数器
unsigned char jsq_1min,jsq_1hours;///////1分计数器和1小时计数器


unsigned  char key_counter;/////////按键计数器
void main(void) 			//主程序//
{   
/////////初始化区////////////////
P3=0xff;/////初始化P3口准备读取按键（按键输入）
P4=0xff;	
//P1_4=0;/////初始化蜂鸣器驱动引脚
int_time0();/////初始化t0定时器
display_ceshi_8();//八位数码管自检	

	
	while(1) 			    //进入循环//以下为无限循环程序区
     	{ 
////////////////利用中断实验时间与数码管的关系,其中采用中断函数计数//////////////////////////////////////
		 display_seg();     //调用数码管显示函数

		 key(); 			//调用按键函数//

	     /*if(flag_baojing==1)
		 	{
			TR1=1;
			//alarm_buzzer();
			//display_seg();
	 		}
		else
			{
			TR1=0;
			}*/
    } 

}
void anjianyin(void)		//蜂鸣器控制（按键音）//
{ 		
	unsigned char k; /////局部变量定义
	for(k=248;k>0;k--) ////内层循环
	{
		fmq=0;
		delay500us();
		fmq=1;
		delay500us();			
	}
}  
///////////////////////////////////////////////////
//函数名称:void key(void)
//函数功能:按键函数
//入口参数:
//出口参数:
//函数说明:
///////////////////////////////////////////////////
void key(void)      //按键函数
{
	
	if(key_1==0)/////////如果按键按下
	{
	  delay10ms();///////延时10ms
	  if(key_1==0)///////按键的确按下
	    {
				anjianyin();
				jsq_1s++;
				if(jsq_1s>=60)
				{
					jsq_1s=0;
				}
				SEG_3=jsq_1s/10;								//显示秒数的十位//
				SEG_4=jsq_1s%10;	
		while(key_1==0){display_seg();}///////按键等待抬起
		}
	}
	if(key_2==0)/////////如果按键按下
	{
	  delay10ms();///////延时10ms
	  if(key_2==0)///////按键的确按下
	    {
		anjianyin();
		jsq_1s--;
		if(jsq_1s>=60)
				{
					jsq_1s=0;
				}
				SEG_3=jsq_1s/10;								//显示秒数的十位//
				SEG_4=jsq_1s%10;			
		while(key_2==0){display_seg();}///////按键等待抬起
		}
	}
	if(key_3==0)/////////如果按键按下
	{
	  delay10ms();///////延时10ms
	  if(key_3==0)///////按键的确按下
	    {
		/////初始化蜂鸣器
		anjianyin();
		key_counter++;
		if(key_counter==1){TR0=1;}
		if(key_counter==2){TR0=0;}
		if(key_counter==3){TR0=0;jsq_1s=0;jsq_2s=0;SEG_3=jsq_1s/10;SEG_4=jsq_1s%10;}
		if(key_counter==4){key_counter=0;TR0=1;}		
		while(key_3==0){display_seg();}///////按键等待抬起
		}
	}
	if(key_4==0)/////////如果按键按下
	{
	  delay10ms();///////延时10ms
	  if(key_4==0)///////按键的确按下
	    {
			anjianyin();
			flag_baojing=!flag_baojing;
			TR0=1;			
		while(key_4==0){display_seg();}///////按键等待抬起
		}
	}
}


///////////////////////////////////////////////////
//函数名称:void baojing(void)
//函数功能:报警函数
//入口参数:
//出口参数:
//函数说明:
///////////////////////////////////////////////////
void baojing(void)
{
unsigned  int baojing_i;
		  for(baojing_i=2;baojing_i>0;baojing_i--)
		   { 
				 L5=~L5;  
				 alarm_buzzer();				 //P1_0取反//
			//delay50us();            //延时500us//
		   }
}
///////////////////////////////////////////////////
//函数名称:void alarm_buzzer(void)
//函数功能:报警子程序
//入口参数:
//出口参数:
//函数说明:
///////////////////////////////////////////////////
void alarm_buzzer(void)		//延时10ms的子程序//
{ 		
		unsigned char k; /////局部变量定义
		for(k=248;k>0;k--) ////内层循环
		{
		fmq=1;
		//delay50us();
			display_seg();  
		fmq=0;
		//delay50us();
			display_seg();  
 		}
		fmq = 1;
}  

///////////////////////////////////////////////////
//函数名称:void display(void)
//函数功能:显示函数
//入口参数:
//出口参数:
//函数说明:
///////////////////////////////////////////////////
void display(void)      //显示函数
{
//////////////持续显示程序/////////////////////////////
	P1=~0xff;///////将计数值送P0口利用LED指示灯以BCD码（8421码）显示
	delay02s();
	delay02s();
	P1=0xff;
//////////////闪烁显示函数/////////////////////////////
/*
	P0=~count;///////将计数值送P0口利用LED指示灯以BCD码（8421码）显示
	delay02s();///延时0.2s
	P0=0xff;///////P0口8条线全送高电平，目的熄灭所有LED指示灯
	delay02s();///延时0.2s
*/
}
///////////////////////////////////////////////////
//函数名称:void display_seg(void)
//函数功能:数码管显示函数
//入口参数:
//出口参数:
//函数说明:
///////////////////////////////////////////////////
void display_seg(void)      //显示函数
{
	
//SEG_8=seg_key%10;
//SEG_7=seg_key/10;	
/////////1位显示//////////////////////
P0=table[SEG_1];//////数据从P0口送出到IC7---74HC573锁存器
P26=0;P26=1;P26=0;///IC7数据锁存
P0=~0x10;//////位码从P0口送出到IC6---74HC573锁存器
P27=0;P27=1;P27=0;///IC6位码数据锁存
     delay500us();///延时500us
/////////黑屏显示//////////////////////
P0=table[17];//////数据从P0口送出到IC7---74HC573锁存器
P26=0;P26=1;P26=0;///IC7数据锁存//////clk信号
P0=~0x00;//////位码从P0口送出到IC6---74HC573锁存器
P27=0;P27=1;P27=0;///IC6位码数据锁存
/////////2位显示//////////////////////
P0=table[SEG_2];//////数据从P0口送出到IC7---74HC573锁存器
P26=0;P26=1;P26=0;///IC7数据锁存
P0=~0x20;//////位码从P0口送出到IC6---74HC573锁存器
P27=0;P27=1;P27=0;///IC6位码数据锁存
     delay500us();///延时500us
/////////黑屏显示//////////////////////
P0=table[17];//////数据从P0口送出到IC7---74HC573锁存器
P26=0;P26=1;P26=0;///IC7数据锁存//////clk信号
P0=~0x00;//////位码从P0口送出到IC6---74HC573锁存器
P27=0;P27=1;P27=0;///IC6位码数据锁存
/////////3位显示//////////////////////
P0=table[SEG_3];//////数据从P0口送出到IC7---74HC573锁存器
P26=0;P26=1;P26=0;///IC7数据锁存
P0=~0x40;//////位码从P0口送出到IC6---74HC573锁存器
P27=0;P27=1;P27=0;///IC6位码数据锁存
     delay500us();///延时500us
/////////黑屏显示//////////////////////
P0=table[17];//////数据从P0口送出到IC7---74HC573锁存器
P26=0;P26=1;P26=0;///IC7数据锁存//////clk信号
P0=~0x00;//////位码从P0口送出到IC6---74HC573锁存器
P27=0;P27=1;P27=0;///IC6位码数据锁存
/////////4位显示//////////////////////
P0=table[SEG_4];//////数据从P0口送出到IC7---74HC573锁存器
P26=0;P26=1;P26=0;///IC7数据锁存
P0=~0x80;//////位码从P0口送出到IC6---74HC573锁存器
P27=0;P27=1;P27=0;///IC6位码数据锁存
     delay500us();///延时500us
/////////黑屏显示//////////////////////
P0=table[17];//////数据从P0口送出到IC7---74HC573锁存器
P26=0;P26=1;P26=0;///IC7数据锁存//////clk信号
P0=~0x00;//////位码从P0口送出到IC6---74HC573锁存器
P27=0;P27=1;P27=0;///IC6位码数据锁存
/////////5位显示//////////////////////
P0=table[SEG_5];//////数据从P0口送出到IC7---74HC573锁存器
P26=0;P26=1;P26=0;///IC7数据锁存
P0=~0x01;//////位码从P0口送出到IC6---74HC573锁存器
P27=0;P27=1;P27=0;///IC6位码数据锁存
     delay500us();///延时500us
/////////黑屏显示//////////////////////
P0=table[17];//////数据从P0口送出到IC7---74HC573锁存器
P26=0;P26=1;P26=0;///IC7数据锁存//////clk信号
P0=~0x00;//////位码从P0口送出到IC6---74HC573锁存器
P27=0;P27=1;P27=0;///IC6位码数据锁存
/////////6位显示//////////////////////
P0=table[SEG_6];//////数据从P0口送出到IC7---74HC573锁存器
P26=0;P26=1;P26=0;///IC7数据锁存
P0=~0x02;//////位码从P0口送出到IC6---74HC573锁存器
P27=0;P27=1;P27=0;///IC6位码数据锁存
     delay500us();///延时500us
/////////黑屏显示//////////////////////
P0=table[17];//////数据从P0口送出到IC7---74HC573锁存器
P26=0;P26=1;P26=0;///IC7数据锁存//////clk信号
P0=~0x00;//////位码从P0口送出到IC6---74HC573锁存器
P27=0;P27=1;P27=0;///IC6位码数据锁存
/////////7位显示//////////////////////
P0=table[SEG_7];//////数据从P0口送出到IC7---74HC573锁存器
P26=0;P26=1;P26=0;///IC7数据锁存
P0=~0x04;//////位码从P0口送出到IC6---74HC573锁存器
P27=0;P27=1;P27=0;///IC6位码数据锁存
     delay500us();///延时500us
/////////黑屏显示//////////////////////
P0=table[17];//////数据从P0口送出到IC7---74HC573锁存器
P26=0;P26=1;P26=0;///IC7数据锁存//////clk信号
P0=~0x00;//////位码从P0口送出到IC6---74HC573锁存器
P27=0;P27=1;P27=0;///IC6位码数据锁存
/////////8位显示//////////////////////
P0=table[SEG_8];//////数据从P0口送出到IC7---74HC573锁存器
P26=0;P26=1;P26=0;///IC7数据锁存
P0=~0x08;//////位码从P0口送出到IC6---74HC573锁存器
P27=0;P27=1;P27=0;///IC6位码数据锁存
     delay500us();///延时500us
/////////黑屏显示//////////////////////
P0=table[17];//////数据从P0口送出到IC7---74HC573锁存器
P26=0;P26=1;P26=0;///IC7数据锁存//////clk信号
P0=~0x00;//////位码从P0口送出到IC6---74HC573锁存器
P27=0;P27=1;P27=0;///IC6位码数据锁存
}
///////////////////////////////////////////////////
//函数名称:void delay500us(void)
//函数功能:延时500us秒的子程序
///////////////////////////////////////////////////
void delay500us(void)		//延时10ms的子程序//
{ 		
		unsigned char k; /////局部变量定义
//  		for(i=20;i>0;i--)   //最外层循环
//			{
//		    	for(j=20;j>0;j--)   // 上层循环
//					{
				  		for(k=248;k>0;k--) ////内层循环
							{
							;
							}
//					}
//			}
}  
///////////////////////////////////////////////////
//函数名称:void delay10ms(void)
//函数功能:延时10ms秒的子程序
///////////////////////////////////////////////////
void delay10ms(void)		//延时10ms的子程序//
{ 		
//		unsigned char i,j,k; /////局部变量定义
		unsigned char j,k; /////局部变量定义
//  		for(i=20;i>0;i--)   //最外层循环
//			{
		    	for(j=20;j>0;j--)   // 上层循环
					{
				  		for(k=248;k>0;k--) ////内层循环
							{
							;
							}
					}
//			}
} 
 
///////////////////////////////////////////////////
//函数名称:void delay50us(void)
//函数功能:延时50us秒的子程序
///////////////////////////////////////////////////
void delay50us(void)		//延时10ms的子程序//
{ 		
		unsigned int k; /////局部变量定义

			for(k=50;k>0;k--) ////内层循环
				{
				;
				}

}  

///////////////////////////////////////////////////
//函数名称:void delay02s(void)
//函数功能:延时0.2秒的子程序
///////////////////////////////////////////////////
void delay02s(void)		//延时子程序//
{ 		
		unsigned char i,j,k; /////局部变量定义
  		for(i=20;i>0;i--)   //最外层循环
			{
		    	for(j=20;j>0;j--)   // 上层循环
					{
				  		for(k=248;k>0;k--) ////内层循环
							{
							;
							}
					}
			}
} 
///////////////////////////////////////////////////
//函数名称:void int_time0(void)
//函数功能:定时器t0初始化
//入口参数:
//出口参数:
//函数说明:
///////////////////////////////////////////////////
void int_time0(void) 
{
	//设置定时器0工作方式//
	TMOD=0x01;								//定义为定时器0方式1 0000 0001//
	//赋值方法1 50ms//
	TH0=(65536-50000)/256;					//赋初值//
	TL0=(65536-50000)%256;
	//赋值方法2//
//	TH0=(65536-50000)>>8;					//赋初值//
//	TL0=(65536-50000);
	//赋初值方法3_16进制赋值法//
//	TH0=0x3c;					//赋初值//
//	TL0=0xb0;

	//打开中断通道//
	ET0=1;									//开启定时器0溢出中断//
	EA=1;									//开启总的中断开关//
///////50ms计数器和1S计数器初始内容清零///////
	jsq_50ms=0;
	jsq_1s=0;
///////显示秒计数器内容准备///////

	SEG_3=jsq_1s/10;							//3数码管显示秒数的十位//
	SEG_4=jsq_1s%10;							//4数码管显示秒数的个位//

///////开表/////
	TR0=1;
									//开启定时器0//
//////////t1设置/////////////////////////////////////////
	TH1=(65536-5000)/256;					//赋初值//
	TL1=(65536-5000)%256;
	ET1=1;									//开启定时器0溢出中断//
//	EA=1;
	TR1=0;
}

///////////////////////////////////////////////////
//函数名称:void	interrupt_t0(void)	interrupt	1
//函数功能:t0中断函数
//入口参数:
//出口参数:
//函数说明:
///////////////////////////////////////////////////
void	interrupt_t0(void)	interrupt	1		//定时器0溢出中断//
{
////////////赋初值//////////////////////////////////
	//赋初值方法1_直接计算法//
	TH0=(65536-50000)/256;					//赋初值//
	TL0=(65536-50000)%256;
	//赋初值方法2_移位和赋值方法//
//	TH0=(65536-50000)>>8;					//赋初值//
//	TL0=(65536-50000);
	//赋初值方法3_16进制赋值法//
//	TH0=0x3c;					//赋初值//
//	TL0=0xb0;

	jsq_50ms++;											//每到一个中断为50毫秒,jsq_50ms加1//
	if(jsq_50ms==20)									//到来20次中断后,每20次一秒;jsq_50ms重新计数//
		{	
		jsq_50ms=0;
 /////////秒计数 /////////
		jsq_1s++;										//每来20次中断即为1秒,jsq_1s加1//
 /////////报警控制_长度控制方法/////////
		if(jsq_1s>=30&&jsq_1s<=40)
			{
			if(flag_baojing==0)
				{baojing();}
			}
		if(jsq_1s>=30)
/////////分计数 /////////
		if(jsq_1s==60)									//每到60秒,进分位，秒清零则重新计时//
			{	
			jsq_1s=0;
			jsq_baojing=0; //复位报警计数器初值
			}


	///////显示秒计数器内容准备///////
        SEG_1=16;
		SEG_2=16;//显示“-”
		SEG_3=jsq_1s/10;								//显示秒数的十位//
		SEG_4=jsq_1s%10;								//显示秒数的个位//


///		if(jsq_1s>=10&&jsq_1s<=20){P1_4=1;}	else{P1_4=0;}							
		}

}


void display_ceshi_8(void)     //8个数码管测试函数 
{
	unsigned int i,k;
	unsigned int j=10;
for(k=0;k<10;k++)
{
	j=j-1;

	  for(i=0;i<100;i++)
	   {
		SEG_1=j;SEG_2=j;SEG_3=j;SEG_4=j;SEG_5=j;SEG_6=j;SEG_7=j;SEG_8=j;
		display_seg();     //8个调用数码管显示函数
		}
}
}